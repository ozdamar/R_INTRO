---
title: "Basic Data Management"
author: "ozge.ozdamar@msgsu.edu.tr"
date: "`r format(Sys.time(), '%B %d %Y')`"
output: 
 html_document:
    df_print: paged
    # theme: sandstone
    # default, cerulean, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    # highlight: haddock
    # default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, and textmate
    header-includes:
       - \usepackage{color}
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: true
    #code_folding: hide
---

<img src="msgsulogo.png" style="position:absolute;top:0px;right:0px;" />


***
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">MSGSU ISTATISTIK BOLUMU - R ILE ISTATISTIKSEL PROGRAMLAMA DERS NOTLARI 2021</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">ozge.ozdamar@msgsu.edu.tr</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.

Hata ve öneriler için `r emo::ji("email")`


***

**REFERENCES**

***

**LIBRARIES**
```{r,eval=FALSE}
rm(list=ls())
.packages = c("car","doBy","lubridate","VIM","mice", "Amelia","naniar","plyr","sqldf", "dplyr", "lubridate")
.inst <- .packages %in% installed.packages()
if(length(.packages[!.inst]) > 0) install.packages(.packages[!.inst])
lapply(.packages, require, character.only=TRUE)
```

***

**FUNCTIONS**
```{r, eval=FALSE}
car::recode()
doBy::recodevar()
base::within(), cut(), 
plyr::revalue(), mapvalues()
```

**data**
```{r,eval=FALSE}
 data(mtcars)
 data(airquality)
```

***

# Create new variable
```{r}
veri<-data.frame(x1 = c(2, 2, 6, 4), x2 = c(3, 4, 2, 8))
veri
```


```{r}
veri$sumx  <-  veri$x1 + veri$x2
veri$meanx <- (veri$x1 + veri$x2)/2
veri
```

```{r}
attach(veri)
veri$sumx  <-  x1 + x2
veri$meanx <- (x1 + x2)/2
detach(veri)
```


```{r}
veri <- base::transform(veri, sumx  =  x1 + x2,  meanx = (x1 + x2)/2)
veri
```


# Recoding variables    

Recoding involves creating new values of a variable conditional on the existing values of the same and/or other variables.

* Change a continuous variable into a set of categories
* Replace miscoded values with correct values
* Create a pass/fail variable based on a set of cutoff scores
* The statement variable[condition] <- expression will only make the assignment when condition is TRUE.

```{r}
head(mtcars)
rank(mtcars$mpg)
```


```{r}
mtcars$mpgcat1[mtcars$mpg  < 10] <-"A"
mtcars$mpgcat1[mtcars$mpg  >= 10  & mtcars$mpg <= 20] <-"B"
mtcars$mpgcat1[mtcars$mpg  > 20] <-"C"                    
mtcars
str(mtcars)
mtcars$mpgcat1 <- as.factor(mtcars$mpgcat1)
str(mtcars)
```

### within
```{r}
mtcars<-within(mtcars,{
             mpgcat2 <- NA
             mpgcat2[mpg < 10] <- "A"
             mpgcat2[mpg >= 10 & mpg <= 20] <- "B"
             mpgcat2[mpg >20] <- "C"  })
mtcars
str(mtcars)
mtcars$mpgcat2 <- as.factor(mtcars$mpgcat2)
str(mtcars)
```

### car::recode()
```{r}
a1<-car::recode(mtcars$carb,"1=10;2=20;3=30;4=40;6=60;8=80")
head(cbind(mtcars$carb,a1),10)
# ?recode
# http://rprogramming.net/recode-data-in-r/
```

### doBy::recodeVar()
```{r}
mtcars$carb2<-doBy::recodeVar(mtcars$carb,src=c(1:8),tgt=c("A","B","C","D","E","F","G","H"))
head(cbind(mtcars$carb2),10) 
str(mtcars) # carb2 char
mtcars$carb2<- as.factor(mtcars$carb2)
str(mtcars)
# ? recodeVar
```

### base::cut()
```{r}
mtcars$mpgcat3<-cut(mtcars$mpg,
                    breaks=c(-Inf,20,30,Inf),
                    labels = c("A","B","C"))
head(mtcars)
```

###plyr::revalue(), mapvalues()
```{r}
mtcars$carb3<-plyr::revalue(as.factor(mtcars$carb),c("1"="A","2"="B","3"="C","4"="D","6"="E"))
mtcars$carb4<-plyr::mapvalues(as.factor(mtcars$carb),from = c("1","2","3","4","6"),to = c("A","B","C","D","E"))
head(mtcars)
```


#  Renaming variables
```{r,eval=FALSE}
fix(mtcars)
edit(mtcars)
data.entry(mtcars)
reshape::rename()
```

```{r}
# rename(mtcars, c(wt = "weight", cyl = "cylinders"))
names(mtcars)
```


#   Missing values   

NA  **N**ot **A**vailable
```{r}
x <- c(1, 99, 3, NA, 5, 5, NA, 99, 3, 3, NA, 1, 3, 5, 1, 1 )
```

```{r}
is.na(x)
```

```{r}
x < 3
```
```{r}
x == 99
```

NA cannot be used in comparisons
```{r}
x == NA 
```

sample data
```{r}
data(airquality)
str(airquality)
is.na(airquality)
```

NA + anything = NA

NaN : Not a Number
any_na(NaN)
any_na(NULL)
any_na(Inf)
```{r}
NA | TRUE
```
```{r}
NA | FALSE
```


```{r}
NA + NaN
```


```{r}
NaN + NA
```

## Recoding values to missing
```{r}
x[x == 99] <- NA
x
```


## Missing data in arguments
```{r, eval=FALSE}
na.omit, na.exclude, na.pass, na.fail, na.action, na.rm, na.last, useNA

```

```{r}
mean(airquality$Ozone)
mean(airquality$Ozone,na.rm=TRUE)
mean(na.omit(airquality$Ozone))
na.omit(airquality$Ozone)
airquality$Ozone
```


```{r}
na.omit(airquality)
```
returns the object with observations removed if they contain any missing values

```{r}
na.exclude(airquality) 
```
differences between omitting and excluding NAs can be seen in some prediction and residual functions

```{r,eval=FALSE}
na.fail(airquality)
```
returns the object only if it contains no missing values

```{r}
na.pass(airquality) 
```
returns the object unchanged

### omit vs exclude
```{r}
omit.model<- lm(Ozone ~ Solar.R, data = airquality, na.action = na.omit)
exclude.model<- lm(Ozone ~ Solar.R, data = airquality, na.action = na.exclude)
```

```{r}
omit.model
```

```{r}
exclude.model
```

```{r}
resid(omit.model)
```

```{r}
resid(exclude.model)
```

```{r,eval=FALSE}
data.frame(resid(omit.model),resid(exclude.model)) # error
```

```{r}
fitted(omit.model)
```

```{r}
fitted(exclude.model)
```

na.omit and na.exclude do not use the missing values, but maintains their position for the residuals and fitted values.

```{r}
summary(airquality$Ozone)
table(airquality$Ozone)
table(airquality$Ozone,useNA="ifany")
table(airquality$Ozone, useNA="always")
```

```{r}
length(airquality$Ozone)
x1 <- sort(airquality$Ozone)
x1
length(x1)
x2 <- sort(airquality$Ozone, na.last = TRUE)
x2
length(x2)
```

## detect, pattern, visualization 
```{r,eval=FALSE}
complete.cases, VIM::countNA(), mice::md.pattern()
```

```{r}
x
complete.cases(x) # tam satirlar
is.na(x)
!complete.cases(x)	
```

```{r}
str(airquality)
dim(airquality)
```

missing data olmayan satirlar
```{r}
airquality[complete.cases(airquality), ]
dim(airquality[complete.cases(airquality), ])
```

en az bir missing data olan satirlar
```{r}
airquality[!complete.cases(airquality), ]
dim(airquality[!complete.cases(airquality), ])
```

 mantiksal operatorlerin sayisal degerleri 1 ve 0 oldugundan,
```{r}
sum(is.na(airquality$Ozone)) # Dream degiskenindeki bos gozlem sayisi 
VIM::countNA(airquality$Ozone) # VIM paketi ile
mean(is.na(sleep$Dream)) # Dream degiskenindeki bos gozlem orani
mean(!complete.cases(sleep)) # veri setinde en az bir bos gozlem olan satir orani
```

**missing data pattern**
```{r}
mice::md.pattern(airquality) # mice paketi
```

** missing data visualization**

VIM package
```{r}
a<-VIM::aggr(airquality, prop=FALSE, numbers=TRUE) # VIM paketi
summary(a) # missing data oruntusu
```

```{r}
VIM::matrixplot(airquality)
VIM::matrixplot(airquality, interactive = TRUE, sortby = "Ozone") #!
```


```{r}
VIM::marginplot(airquality[,c("Ozone","Solar.R")])
VIM::marginplot(airquality[c("Ozone","Solar.R")], pch=c(20),col=c("darkgray", "red", "blue"))
```

```{r}
VIM::marginmatrix(airquality[,-5])
```

```{r}
VIM::barMiss(airquality[,c("Month","Ozone")])
airquality[,c("Month","Ozone")] # grafik verisini gormek icin
```

```{r}
plot(airquality$Ozone, airquality$Solar.R)
VIM::rugNA(airquality$Ozone, airquality$Solar.R,side=1) # y eksenindeki missingleri x ekseni uzerinde gosteriyor
VIM::rugNA(airquality$Ozone, airquality$Solar.R,ticksize = 1, col= "orange", side=2) # miss argumani ekleyerek missing yerine imputed veriler gosterilebilir ?rugNA bakiniz
```


```{r}
VIM::scattmatrixMiss(airquality) # all variables highlighted, delimiter argumani imputed degerler icin kullanilir, ?scattmatrixMiss
```

```{r}
VIM::scattmatrixMiss(airquality, highlight = "Ozone")
```

```{r}
VIM::pbox(airquality) # parallel boxplots obs ve miss icin
```

```{r}
VIM::parcoordMiss(airquality) #paralel koordinatlar grafigi
```

```{r}
VIM::scattJitt(airquality[,1:2]) # Ozone ve Solar.R icin jittered scatterplot
plot(airquality[,1:2])
```

```{r}
VIM::spineMiss(airquality[,c("Month","Solar.R")]) # spineplot /spinogram
```

```{r}
VIM::scattMiss(airquality[,c("Ozone","Solar.R")]) # missing data line ile gosterilir
```

```{r}
VIM::mosaicMiss(airquality, high = 4, plotvars = 5:6) # mosaic plot
```

Amelia paketi ile gorsellestirme
```{r}
Amelia::missmap(airquality)
```


# Date values
```{r}
Bugun <- Sys.Date()
Bugun
class(Bugun)
typeof(Bugun)
mode(Bugun)
```

```{r}
Bu.an<-Sys.time()
Bu.an
class(Bu.an)
typeof(Bu.an)
mode(Bu.an)
```

```{r}
date()
```

YYYY-MM-DD
```{r}
yarin <- as.Date("2018-05-05")
yarin
weekdays(Bugun)
```


```{r}
haftaya<-Bugun+7
haftaya
```


```{r}
x1<-1:15
Bugun + x1
seq(Bugun, by=2, length.out = 15)
```

use different date format  
```{r}
as.Date("Jan-10-2018", format = "%b-%d-%Y")
as.Date("January-10-2018", format = "%b-%d-%Y")
```

```{r}
dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
as.Date(dates, "%m/%d/%y")
```

%Y = year in extended form: 2018
%y = year in short form: 18
%B = month in extended form: February
%b = month in short form : Feb
%m = month in numeric form : 2
%d = day of the month : 15
%j = month of the year : 2
%H = hour(24 hours) : 22
%I = hour (12 hours) : 10
%M = minutes
%S = seconds

to specify time zone, use PoSIXct(), POSIXIt()

```{r}
zaman1 <- "May 5, 2018, 12:57:10"
zaman1.format <- "%B %d, %Y, %H:%M:%S"
```

```{r}
zaman1.ct <- as.POSIXct(zaman1, format=zaman1.format, tz="GMT")
zaman1.ct
class(zaman1.ct)
typeof(zaman1.ct)
mode(zaman1.ct)
zaman1.lt<- as.POSIXlt(zaman1.ct)
zaman1.lt
class(zaman1.lt)
typeof(zaman1.lt)
mode(zaman1.lt)
unclass(zaman1.lt)
```

parse date: read date from text
```{r}
zaman2 <- c("15:10:00 20/03/2018", "16:00:35 19/01/2017",
            "10:20:30 05/12/2017", "12:15:15 30/06/2018",
            "11:20:35 21/04/2017", "15:50:00 11/09/2018")
zaman2_str <- strptime(zaman2, "%H:%M:%S %d/%m/%Y",tz = "UTC")
zaman2_str
mode(zaman2_str)
```

for more library(lubridate)


#   Type conversions  

test
```{r, eval=FALSE}
is.numeric(),  is.character(),  is.vector(),  is.matrix(), is.data.frame(),
is.factor(), is.logical(), is.numeric()
```

convert
```{r, eval=FALSE}
as.character(),  as.vector(), as.matrix(),  as.data.frame(),
as.factor(), as.logical()
```

more with libraries

#   Sorting data     

```{r}
mtcars <- mtcars[order(mtcars$mpg),]
head(mtcars)
mtcars1 <- mtcars[order(mtcars$mpg, mtcars$disp),] # 1st then by 2nd
head(mtcars1)
mtcars2 <- mtcars[order(mtcars$mpg,-mtcars$qsec),]  # - desc
head(mtcars2)
```


#   Merging datasets     

```{r}
x <- data.frame(k1 = c(NA,NA,3,4,5), k2 = c(1,NA,NA,4,5), data = 1:5)
y <- data.frame(k1 = c(NA,2,NA,4,5), k2 = c(NA,NA,3,4,5), data = 1:5)
```

1. add column
```{r}
cbind(x,y)
```

inner join
```{r}
x
y
merge(x, y, by = "k1") # NA's match, so 6 rows
merge(x, y, by = "k2", incomparables = NA) # 2 rows
merge(x, y, by = c("k1","k2")) # NA's match
```

2.add row
```{r}
rbind(x,y)
```

#   Subsetting datasets     #

```{r, eval=FALSE}
dataframe[row indices, column indices]
```

```{r}
a1 <- mtcars[, c(2,4)]
head(a1)
```

```{r}
isim1 <- c("cyl", "hp", "qsec")
a2 <-mtcars[isim1]
head(a2)
```

```{r}
a3 <- mtcars[c(-2,-4)]
head(a3)
```

```{r}
a4 <- mtcars
a4$carb <- a4$wt <- NULL
head(a4)
```

```{r}
a5 <- mtcars[1:3,]
head(a5)
```

```{r}
a6<- mtcars[which(mtcars$cyl==6 & mtcars$disp == 160),]
head(a6)
```

#   SQL statements to manipulate data frames   #
```{r}
library(sqldf)
newdf <- sqldf("select * from mtcars where carb=1 order by mpg",
               row.names=TRUE)
```

```{r}
sqldf("select avg(mpg) as avg_mpg, avg(disp) as avg_disp, gear
      from mtcars where cyl in (4, 6) group by gear")
```

```{r}
crashes <- read.csv("crashes.csv")
roads <- read.csv("roads.csv")
head(crashes)
print(roads)
```

```{r}
join_string <- "select crashes.* , roads.District, roads.Length
                            from crashes
                            left join roads
                            on crashes.Road = roads.Road"

join_string
```

```{r}
crashes_join_roads <- sqldf(join_string, stringsAsFactors = FALSE)
crashes_join_roads

join_string2 <- "select crashes.* , roads.District, roads.Length
                      from crashes
                      inner join roads
                      on crashes.Road = roads.Road"

crashes_join_roads2<- sqldf(join_string2, stringsAsFactors = FALSE)
head(crashes_join_roads2) 
```
The merge statement in base R can perform the equivalent of inner and 
left joins, as well as right and full outer joins, which are unavailable
in sqldf.
```{r}
crashes_merge_roads <- merge(crashes, roads, by = c("Road"))
crashes_merge_roads
```

```{r}
crashes_merge_roads2 <- merge(crashes, roads, by = c("Road"), all.x = TRUE)
crashes_merge_roads2
```

```{r}
crashes_merge_roads3 <- merge(crashes, roads, by = c("Road"), all.y = TRUE)
crashes_merge_roads3
```

```{r}
crashes_merge_roads4 <- merge(crashes, roads, by = c("Road"), all.x = TRUE, 
                              all.y = TRUE)
crashes_merge_roads4
```

Modifying the inner join query to include a where is the equivalent of
 combining merge and subset statements.

```{r}
join_string2 <- "select  crashes.* , roads.District, roads.Length
                  from crashes
                  inner join roads
                  on crashes.Road = roads.Road
                  where crashes.Road = 'US-40'"                

crashes_join_roads4 <- sqldf(join_string2,stringsAsFactors = FALSE)
crashes_join_roads4
```
Aggregate functions available using SQLite can be used through the use of 
 a group by clause.
```{r}
group_string <- "select crashes.Road, avg(crashes.N_Crashes) as Mean_Crashes
                  from crashes
                  left join roads
                  on crashes.Road = roads.Road
                  group by 1"
sqldf(group_string)
```
While sqldf can make certain data manipulation operations easier,
more advanced data manipulation tasks and calculations must be performed 
in R, such as using Hadley Wickham's plyr package.

```{r}
plyr::ddply(crashes_merge_roads,
      c("Road"),
      function(X) data.frame(Mean_Crashes = mean(X$N_Crashes),
                             Q1_Crashes = quantile(X$N_Crashes, 0.25),
                             Q3_Crashes = quantile(X$N_Crashes, 0.75),
                             Median_Crashes = quantile(X$N_Crashes, 0.50))
)
```


# strings

## creating strings
```{r}
c1 <- "Mustafa Akgül" 
c2 <- "Özgür Yazılım Kış Kampı"  
paste(c1, c2)
```

```{r}
paste("The life of", pi)
```
```{r}
paste("I", "love", "R")
```

```{r}
paste("I", "love", "R", sep = "-")
```

```{r}
paste0("I", "love", "R")
```

```{r}
paste("R", 1:5, sep = " v1.")
```

```{r}
paste0("R", 1:5, sep = " v1.")
```


## convert to string
```{r}
c3<-pi
c3<-as.character(pi)
c3
```


```{r}
toString(c("Aug", 24, 1980))
```

## printing strings

* `print()`: generic printing
* `noquote()`: print with no quotes
* `cat()`: concatenate and print with no quotes
* `sprintf()`: a wrapper for the C function sprintf, that returns a character vector containing a formatted combination of text and variable values

```{r}
print(c2)
```

```{r}
print(c2, quote = FALSE)
```

```{r}
noquote(c2)
```

Another very useful function is `cat()` which allows us to concatenate objects and print them either on screen or to a file. The output result is very similar to `noquote()`; however, `cat()` does not print the numeric line indicator. As a result, `cat()` can be useful for printing nicely formatted responses to users.

```{r}
noquote(c2)
cat(c2)
```

```{r}
cat(c2, "2020")
```

```{r}
cat(letters)
```

```{r}
cat(letters, sep = "-")
```

```{r}
cat(letters, sep = "")
```

long strings
```{r}
cat(c1,c2, fill=1)
```

`sprintf()` is a useful printing function for precise control of the output. It is a wrapper for the C function sprintf and returns a character vector containing a formatted combination of text and variable values.To substitute in a string or string variable, use %s:

```{r}
c2
sprintf("Mustafa Akgül %s 2020", c2)
```

```{r}
sprintf("Hoşgeldin %s %s 2020",c1,c2)
```

```{r}
r<-3
sprintf("Kullandığım R versiyonu:%d",r)
```

 print with leading spaces
```{r}
r<-3
sprintf("Kullandığım R versiyonu:%4d",r)
```

can also lead with zeros

```{r}
r<-3
sprintf("Kullandığım R versiyonu:%04d",r)
```

For floating-point numbers, use %f for standard notation, and %e or %E for exponential notation:

 '%f' indicates 'fixed point' decimal notation
```{r}
sprintf("%f", pi)
```

 decimal notation with 3 decimal digits
```{r}
sprintf("%.3f", pi)
```


1 integer and 0 decimal digits
```{r}
sprintf("%1.0f", pi)
```

decimal notation with 5 total decimal digits and only 1 to the right of the decimal point
```{r}
sprintf("%5.1f", pi)
```
 
 fill empty digits with zeros
```{r}
sprintf("%05.1f", pi)
```

print with sign (positive)
```{r}
sprintf("%+f", pi)
```

prefix a space
```{r}
sprintf("% f", pi)
```

exponential decimal notation 'e'
```{r}
sprintf("%e", pi)
```

exponential decimal notation 'E'
```{r}
sprintf("%E", pi)
```


## counting strings
```{r}
length("Bir berber bir berbere gel beraber bir berber dükkanı açalım demiş")
```

```{r}
length(c("Bir","berber","bir","berbere","gel","beraber","bir","berber", "dükkanı","açalım","demiş"))
```

```{r}
nchar("Bir berber bir berbere gel beraber bir berber dükkanı açalım demiş")
```

```{r}
nchar(c("Bir","berber","bir","berbere","gel","beraber","bir","berber", "dükkanı","açalım","demiş"))
```


#string manupilation with base R


To replace a character/s

```{r}
x <- "This is A string."
chartr(old = "A", new = "a", x)
```

replace any 'd' with 't' and any 'z' with 'a'
```{r}
y <- "Tomorrow I plzn do lezrn zbout dexduzl znzlysis."
chartr(old = "dz", new = "ta", y)
```

Note that chartr() replaces every identified letter for replacement so the only time I use it is when I am certain that I want to change every possible occurrence of a letter.

String Abbreviations

```{r}
streets <- c("Main", "Elm", "Riverbend", "Mario", "Frederick")
# default abbreviations
abbreviate(streets)
```

```{r}
# set minimum length of abbreviation
abbreviate(streets, minlength = 2)
```

Extract/Replace Substrings

To extract or replace substrings in a character vector there are three primary base R functions to use: substr(), substring(), and strsplit(). The purpose of substr() is to extract and replace substrings with specified starting and stopping characters:

```{r}
alphabet <- paste(LETTERS, collapse = "")
# extract 18th character in string
substr(alphabet, start = 18, stop = 18)
```


```{r}
# extract 18-24th characters in string
substr(alphabet, start = 18, stop = 24)
```

```{r}
# replace 19-24th characters with `R`
substr(alphabet, start = 19, stop = 24) <- "RRRRRR"
alphabet
```

The purpose of substring() is to extract and replace substrings with only a specified starting point. substring() also allows you to extract/replace in a recursive fashion:

```{r}
alphabet <- paste(LETTERS, collapse = "")
# extract 18th through last character
substring(alphabet, first = 18)
```

recursive extraction; specify start position only
```{r}
substring(alphabet, first = 18:24)
```

 recursive extraction; specify start and stop positions
```{r}
 substring(alphabet, first = 1:5, last = 3:7)
```


To split the elements of a character string use strsplit():

```{r}
z <- "The day after I will take a break and drink a beer."
strsplit(z, split = " ")
```

```{r}
a <- "Alabama-Alaska-Arizona-Arkansas-California"
strsplit(a, split = "-")
```

```{r}
unlist(strsplit(a, split = "-"))
```



# String Manipulation with stringr

There are three stringr functions that are closely related to their base R equivalents, but with a few enhancements:

* Concatenate with str_c()
* Number of characters with str_length()
* Substring with str_sub()

str_c() is equivalent to the paste() functions:

 same as paste0()
```{r}
library(stringr)
str_c("Learning", "to", "use", "the", "stringr", "package")
```

same as paste()
```{r}
str_c("Learning", "to", "use", "the", "stringr", "package", sep = " ")
```

 allows recycling
```{r}
str_c(letters, " is for", "...")
```

str_length() is similar to the nchar() function; however, str_ length() behaves more appropriately with missing (‘NA’) values:

 some text with NA
```{r}
text = c("Learning", "to", NA, "use", "the", NA, "stringr", "package")
```

 compare `str_length()` with `nchar()`
```{r}
nchar(text)
str_length(text)
```


str_sub() is similar to substr(); however, it returns a zero length vector if any of its inputs are zero length, and otherwise expands each argument to match the longest. It also accepts negative positions, which are calculated from the left of the last character.

```{r}
x <- "Learning to use the stringr package"
```

 alternative indexing
```{r}
str_sub(x, start = 1, end = 15)
```

```{r}
str_sub(x, end = 15)
```

```{r}
str_sub(x, start = 17)
```

```{r}
str_sub(x, start = c(1, 17), end = c(15, 35))
```


using negative indices for start/end points from end of string

```{r}
str_sub(x, start = -1)
```

```{r}
str_sub(x, start = -19)
```

```{r}
str_sub(x, end = -21)
```

Replacement
```{r}
str_sub(x, end = 15) <- "I know how to use"
x
```


## Duplicate Characters Within a String

```{r}

str_dup("beer", times = 3)
```

```{r}
str_dup("beer", times = 1:3)
```


 use with a vector of strings

```{r}
states_i_luv <- state.name[c(6, 23, 34, 35)]
str_dup(states_i_luv, times = 2)
```

Remove Leading and Trailing Whitespace

```{r}
text <- c("Text ", " with", " whitespace ", " on", "both ", " sides ")
```

 remove whitespaces on the left side
```{r}
str_trim(text, side = "left")
```

 remove whitespaces on the right side
```{r}
str_trim(text, side = "right")
```

 remove whitespaces on both sides
```{r}
str_trim(text, side = "both")
```

## Pad a String with Whitespace

To add whitespace, or to pad a string, use str_pad(). You can also use str_ pad() to pad a string with specified characters.

```{r}
str_pad("beer", width = 10, side = "left")
```

```{r}
str_pad("beer", width = 10, side = "both")
```

```{r}
str_pad("beer", width = 10, side = "right", pad = "!")
```

## Set Operatons for Character Strings
**Set Union**
```{r}
set_1 <- c("lagunitas", "bells", "dogfish", "summit", "odell")
set_2 <- c("sierra", "bells", "harpoon", "lagunitas", "founders")
union(set_1, set_2)
```


**Set Intersection**
To obtain the common elements of two character vectors use intersect():

```{r}
intersect(set_1, set_2)
```

## Identifying Different Elements
To obtain the non-common elements, or the difference, of two character vectors use setdiff():

returns elements in set_1 not in set_2
```{r}
setdiff(set_1, set_2)
```

 returns elements in set_2 not in set_1
```{r}
setdiff(set_2, set_1)
```

## Testing for Element Equality
To test if two vectors contain the same elements regardless of order use setequal():
```{r}
set_3 <- c("woody", "buzz", "rex")
set_4 <- c("woody", "andy", "buzz")
set_5 <- c("andy", "buzz", "woody")
setequal(set_3, set_4)
```

```{r}
setequal(set_4, set_5)
```

## Testing for Exact Equality
To test if two character vectors are equal in content and order use identical():

```{r}
set_6 <- c("woody", "andy", "buzz")
set_7 <- c("andy", "buzz", "woody")
set_8 <- c("woody", "andy", "buzz")
identical(set_6, set_7)
```

```{r}
identical(set_6, set_8)
```

Identifying If Elements Are Contained in a String
To test if an element is contained within a character vector use is.element() or %in%:
```{r}
good <- "andy"
bad <- "sid"
is.element(good, set_8)
```

```{r}
good %in% set_8
```

```{r}
bad %in% set_8
```


## Sorting a String
```{r}
sort(set_8)
```

```{r}
sort(set_8, decreasing = TRUE)
```

# Regular Expression

A regular expression (aka regex) is a sequence of characters that define a search pattern, mainly for use in pattern matching with text strings.

```{r, eval=FALSE}
help(regex)
```


## metacharacters

